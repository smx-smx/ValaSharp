using GLibPorts;
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.IO.MemoryMappedFiles;
using System.Linq;
using System.Security.AccessControl;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading.Tasks;
using Vala;
using ValaConfig;

namespace CLanguage
{
	/**
	 * Represents a writer to write C source files.
	 */
	public class CCodeWriter
	{
		/**
		 * Specifies the file to be written.
		 */
		public string filename { get; set; }

		/**
		 * Specifies the source file used to generate this one.
		 */
		private string source_filename;

		/**
		 * Specifies whether to emit line directives.
		 */
		public bool line_directives { get; set; }

		/**
		 * Specifies whether the output stream is at the beginning of a line.
		 */
		public bool bol {
			get { return _bol; }
		}

		static Regex fix_indent_regex;

		private string temp_filename;
		private bool file_exists;

		private GLib.FileStream stream;

		private int indent;
		private int current_line_number = 1;
		private bool using_line_directive;

		/* at begin of line */
		private bool _bol = true;

		public CCodeWriter(string filename, string source_filename = null) {
			this.filename = filename;
			this.source_filename = source_filename;
		}

		/**
		 * Opens the file.
		 *
		 * @return true if the file has been opened successfully,
		 *         false otherwise
		 */
		public bool open(bool write_version) {
			file_exists = File.Exists(filename);
			if (file_exists) {
				temp_filename = "%s.valatmp".printf(filename);
				stream = GLib.FileStream.open(temp_filename, "w");
			} else {
				/*
				 * File doesn't exist. In case of a particular destination (-d flag),
				 * check and create the directory structure.
				 */
				var dirname = Path.GetDirectoryName(filename);
				Directory.CreateDirectory(dirname);
				stream = GLib.FileStream.open(filename, "w");
			}

			if (stream == null) {
				return false;
			}

			var opening = write_version ?
				"/* %s generated by valac %s, the Vala compiler".printf(Path.GetFileName(filename), Config.BUILD_VERSION) :
				"/* %s generated by valac, the Vala compiler".printf(Path.GetFileName(filename));
			write_string(opening);

			// Write the file name if known
			if (source_filename != null) {
				write_newline();
				write_string(" * generated from %s".printf(Path.GetFileName(source_filename)));
			}

			write_string(", do not modify */");
			write_newline();
			write_newline();

			return true;
		}

		/**
		 * Closes the file.
		 */
		public void close() {
			stream.Dispose();

			if (file_exists) {
				var changed = true;

				try {
					var old_file = MemoryMappedFile.OpenExisting(filename);
					var new_file = MemoryMappedFile.OpenExisting(temp_filename);
					var len = old_file.CreateViewStream().Length;
					var st1 = old_file.CreateViewStream();
					var st2 = new_file.CreateViewStream();
					if (len == st2.Length)
					{
						byte[] data1 = new byte[len];
						byte[] data2 = new byte[len];
						st1.Read(data1, 0, (int)len);
						st2.Read(data1, 0, (int)len);

						if(data1 == data2) {
							changed = false;
						}
					}
					old_file.Dispose();
					new_file.Dispose();
				} catch (Exception) {
					// assume changed if mmap comparison doesn't work
				}

				if (changed) {
					if(File.Exists(filename))
						File.Delete(filename);
					File.Move(temp_filename, filename);
				} else {
					File.Delete(temp_filename);
					if (source_filename != null)
					{
						var atime = File.GetLastAccessTime(source_filename);
						var mtime = File.GetLastWriteTime(source_filename);

						var t_atime = File.GetLastAccessTime(filename);
						var t_mtime = File.GetLastWriteTime(filename);

						if (mtime >= t_mtime) {
							File.SetLastAccessTime(filename, atime.AddSeconds(1));
							File.SetLastWriteTime(filename, mtime.AddSeconds(1));
						}
					}
				}
			}
		}

		/**
		 * Writes tabs according to the current indent level.
		 */
		public void write_indent(CCodeLineDirective line = null) {
			if (line_directives) {
				if (line != null) {
					line.write(this);
					using_line_directive = true;
				} else if (using_line_directive) {
					// no corresponding Vala line, emit line directive for C line
					string path = Path.GetFileName(filename);
					path = path.Replace("\\", "/");

					write_string("#line %d \"%s\"".printf(current_line_number + 1, path));
					write_newline();
					using_line_directive = false;
				}
			}

			if (!_bol) {
				write_newline();
			}

			stream.puts(gstring.nfill(indent, '\t'));
			_bol = false;
		}

		/**
		 * Writes the specified string.
		 *
		 * @param s a string
		 */
		public void write_string(string s) {
			stream.puts(s);
			_bol = false;
		}

		/**
		 * Writes a newline.
		 */
		public void write_newline() {
			stream.putc('\n');
			current_line_number++;
			_bol = true;
		}

		/**
		 * Opens a new block, increasing the indent level.
		 */
		public void write_begin_block() {
			if (!_bol) {
				stream.putc(' ');
			} else {
				write_indent();
			}
			stream.putc('{');
			write_newline();
			indent++;
		}

		/**
		 * Closes the current block, decreasing the indent level.
		 */
		public void write_end_block() {
			Debug.Assert(indent > 0);

			indent--;
			write_indent();
			stream.putc('}');
		}

		/**
		 * Writes the specified text as comment.
		 *
		 * @param text the comment text
		 */
		public void write_comment(string text) {
			try {
				write_indent();
				stream.puts("/*");
				bool first = true;

				// discard tabs at beginning of line
				if (fix_indent_regex == null)
					fix_indent_regex = new Regex("^\t+"); ;

				foreach (string line in text.Split('\n')) {
					if (!first) {
						write_indent();
					} else {
						first = false;
					}

					var lineparts = fix_indent_regex.Replace(line, "").Split(new string[]{"*/"}, StringSplitOptions.None);
					stream.puts(string.Join("* /", lineparts));
				}
				stream.puts("*/");
				write_newline();
			} catch (Exception) {
				// ignore
			}
		}
	}
}
